本文档主要用于梳理集成学习相关知识点。

## 1.Bagging ##

Bagging基本流程，有放回地采样出T个含有m个训练样本的采样集，然后基于每个采样集训练出一个基学习器，再将这些基学习器进行结合,对预测输出进行结合时，通常采用简单投票法（分类任务），通常采用简单平均法（回归任务）；

### 1.1 Random Forest ###

Random Forest是Bagging的一个扩展体，RF在以决策树为基学习器构建Bagging的基础上，进一步在决策树的训练过程中引入了随机属性选择；

两个随机：1）样本随机采样；2）属性随机选择；

## 2.Boosting ##

Boosting是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制：先从初始训练集中训练出一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的训练样本在后续受到更多关注，然后基于调整后的样本分布来训练下一个基学习器；如此重复进行，直至基学习器数目达到事先指定的值T，最终将这T个基学习器进行**加权**结合。Boosting族算法最著名的代表是AdaBoost。

Boosting算法要求基学习器能对特定的数据分布进行学习，这可通过“重赋权法”(re-weighting)实施，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重。对无法接受带权样本的基学习算法，则可通过“重采样法”(re-sampling)来处理，即在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得的样本集对基学习器进行训练。一般而言，这两种做法没有显著的优劣差别。

### 2.1 AdaBoost ###

AdaBoost算法有多种推导方式，比较容易理解的是基于“加性模型”(additive model)，即基学习器的线性组合

$H(x)=\sum_{t=1}^{T}\alpha_{t} * h_{t}(x)$

来最小化指数损失函数(exponential loss function)

$\ell_{exp}(H|D)=\mathbb{E}_{x \backsim D}[e^{-f(x)H(x)}]$

AdaBoost算法基本流程，

****
**输入：** 训练集D={(x1,y1),(x2,y2),...,(xm,ym)};

基学习算法c；

训练轮数T；

**过程:**

    1:初始化样本权值分布；
    2:for t = 1,2,3..T do
    3:    基于分布Dt从数据集D中训练出分类器ht;
    4:    估计ht的误差；
    5:    if 误差大于0.5 then break；
    6:    确定分类器ht的权重；
    7:    更新样本分布；
    8:end for

**输出:** $H(x) = sign(\sum_{t=1}^{T}\alpha_{t}h_{t}(x))$；

1:$D_{1}(x)=1/m$；

3:$h_{t}(x)=c(D,D_{t})$；

4:$\epsilon_{t}=P_{x \backsim D_{t}}(h_{t}(x) \neq f(x))$；

6:$\alpha_{t}=\frac{1}{2}ln(\frac{1-\epsilon_{t}}{\epsilon_{t}})$ 分类器的权值；

7:$D_{t+1}(x_{i})=\frac{D_{t}(x_{i})}{Z_{t}}exp(-\alpha_{t}),h_{t}(x_{i}) = f(x_{i})$；

$D_{t+1}(x_{i})=\frac{D_{t}(x_{i})}{Z_{t}}exp(\alpha_{t}),h_{t}(x_{i}) \neq f(x_{i})$；

$D_{t+1}(x_{i})=\frac{D_{t}(x_{i})exp(-\alpha_{t}f(x_{i})h_{t}(x_{i}))}{Z_{t}}$ 样本的权重；

$Z_{t}=\sum_{i=1}^{m}D_{t}(x_{i})exp(-\alpha_{t}f(x_{i}h_{t}(x_{i})))$ 是规范化因子，以确保Dt+1是一个分布；

****

两个权值调整：1)每次迭代中分配正确的样本权值降低，分配错误的样本权值增加；2)T次迭代中，正确率高的分类器权值较高，正确率低的分类器权值较低；

### 2.2 提升树 ###

提升树是以分类树或者回归树为基本分类器的提升方法。

提升方法实际采用加性模型(即基学习器的线性组合)与前向分步算法。以决策树为基学习器的提升算法称为提升树(boosting tree)。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。

针对不同问题的提升树算法，主要区别在于使用不同的损失函数，包括平方误差损失函数的回归问题，指数损失函数的分类问题，以及用一般损失函数的一般决策问题。

回归问题的提升树算法：

***
**输入：** 训练集D={(x1,y1),(x2,y2),...,(xm,ym)};

训练轮数T；

**过程:**

    1:初始化；
    2:for t = 1,2,3..T do
    3:    计算各个样本的残差;
    4:    拟合残差，学习一个回归树；
    5:    更新回归树；
    6:end for

**输出:** $f_{T}(x) = \sum_{t=1}^{T}T(x;\Theta_{t})$；

1:$f_{0}(x)=0$；

3:$r_{ti}=y_{i}-f_{t-1}(x_{i}),i=1,2,3,...m$；

4:$T(x;\Theta_{t})$ 即为学习的回归树；

5:$f_{t}(x)=f_{t-1}(x)+T(x;\Theta_{t})$ 用于更新；

***

### 2.3 GBDT ###

提升树利用加性模型与前向分步算法实现学习的优化过程。当损失函数是平方损失函数和指数损失函数使，每一步优化是很简单的。但是对于一般损失函数而言，往往每一步优化并不是那么容易。梯度提升算法，利用最速下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值。

$-[\frac{\partial L(y,f(x_{i}))}{\partial f(x_{i})}]_{f(x)=f_{m-1}(x)}$，即为所求的梯度；

***
**输入：** 训练集D={(x1,y1),(x2,y2),...,(xm,ym)};

训练轮数T；

**过程:**

    1:初始化；
    2:for t = 1,2,3..T do
    3:    计算各个样本的梯度;
    4:    对梯度拟合一个回归树，得到第t棵树的叶结点；
    5:    估计叶结点区域的值；
    6:    更新回归树；
    7:end for

**输出:** $f_{T}(x) = \sum_{t=1}^{T}\sum_{j=1}^{J}c_{tj}I(x\in R_{tj})$；

1:$f_{0}(x)=argmin_{c}\sum_{i=1}^{m}L(y_{i},c)$ 初始化，估计使损失函数最小化的常数值，它是只有一个根结点的树；

3:$r_{ti}=-[\frac{\partial L(y,f(x_{i}))}{\partial f(x_{i})}]_{f(x)=f_{m-1}(x)} ,i=1,2,3,...m$ 计算损失函数的负梯度在当前模型的值，将它作为残差的估计，对于平方损失函数，它就是通常所说的残差，对于一般损失函数，它就是残差的近似值；

4:$R_{tj},j=1,2,3,..J$ 估计回归树叶结点区域，以拟合残差的近似值；

5:$c_{tj}=argmin_{c}(\sum_{x_{i}\in R_{tj}}L(y_{i},f_{m-1}(x_{i})+c))$ 利用线性搜索估计叶结点区域的值，使损失函数最小化；

6:$f_{t}(x)=f_{t-1}(x)+\sum_{j=1}^{J}c_{tj}I(x\in R_{tj})$ 更新回归树；

***

## 3.结合策略 ##

学习器结合可能会从三个方面带来好处，
1. 统计角度，由于学习任务的假设空间往往很大，可能有多个假设在训练集上达到同等性能，此时若使用单学习器可能因误导而导致泛化性能不佳，结合多个学习器则会减少这一风险；
2. 计算角度，学习算法往往会陷入局部极值，有的局部极值点所对应的泛化性能可能很高早，而通过多次运行之后进行结合，可能降低陷入糟糕的局部极值点的风险；
3. 表示角度，某些学习任务的真实假设可能不在当前学习算法所考虑的假设空间中，此时若使用单学习器则肯定无效，而通过结合多个学习器，由于相应的假设空间有所扩大，有可能学得更好的近似；

### 3.1平均法 ###
1. 简单平均法

    $H(x)=\frac{1}{T}\sum_{t=1}^{T}h_{t}(x)$

2. 加权平均法

    $H(x)=\sum_{t=1}^{T}w_{t}h_{t}(x)$

    $w_t，w_t\ge 0,\sum_{t=1}^{T}w_t = 1$ 是个体学习器的权重；

### 3.2投票法 ###
1. 绝对多数投票法

    $H(x)=c_j,if(\sum_{t=1}^{T}h_{t}^{j}>0.5\sum_{k=1}^{N}\sum_{t=1}^{T}h_{t}^{k}(x)),else(reject)$

    即若某标记得票超过半数，则预测为该标记；否则，拒绝预测；

2. 相对多数投票法

    $H(x)=c_{argmax_j}\sum_{t=1}^{T}h_{t}^{j}(x)$

    即某预测为得票最多的标记，若同时有多个标记获得最高票，则从中随机选取一个；

3. 加权投票法

    $H(x)=c_{argmax_j}\sum_{t=1}^{T}w_th_{t}^{j}(x)$

    $w_t，w_t\ge 0,\sum_{t=1}^{T}w_t = 1$ 是个体学习器的权重；

### 3.3学习法 ###

当训练数据很多时，一种更为强大的结合策略是使用“学习法”，即通过另一个学习器来进行结合。Stacking是学习法的典型代表，我们把个体学习器称为初级学习器，用于结合的学习器称为次级学习器或元学习器(meta-learner)。

Stacking先从初始数据集训练出初级学习器，然后“生成”一个新数据集用于训练次级学习器。在这个新数据集中，初级学习器的输出被当作样例输入特征，而初始样本的标记仍被当作样例标记。

在训练阶段，次级训练集是利用初级学习器产生的，若直接使用初级学习器的训练集来产生次级训练集，则过拟合风险会比较大；因此，一般是通过使用交叉验证或留一法这种方式，用训练初级学习器未使用的样本来产生次级学习器的训练样本。

## 4.多样性 ##

### 4.1误差-分歧分解 ###

### 4.2多样性度量 ###

### 4.3多样性增强 ###

1. 数据样本扰动
2. 输入属性扰动
3. 输出表示扰动
4. 算法参数扰动
